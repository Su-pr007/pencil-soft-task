# Четвёртое задание (Оптимизация)

## Условие задания
```
Проведите рефакторинг, исправьте баги и прокомментируйте код, приведённый ниже.
```
Исходный код:
```php
function load_users_data($user_ids) {
    $user_ids = explode(',', $user_ids);
    foreach ($user_ids as $user_id) {
        $db = mysqli_connect("localhost", "root", "123123", "database");
        $sql = mysqli_query($db, "SELECT * FROM users WHERE id=$user_id");
        while($obj = $sql->fetch_object()){
            $data[$user_id] = $obj->name;
        }
        mysqli_close($db);
    }
    return $data;
}
// Как правило, в $_GET['user_ids'] должна приходить строка
// с номерами пользователей через запятую, например: 1,2,17,48
$data = load_users_data($_GET['user_ids']);
foreach ($data as $user_id=>$name) {
    echo "<a href=\"/show_user.php?id=$user_id\">$name</a>";
}
```

## Решение

Если на проекте используется PHP версии 8
```php
const DB_HOST = "localhost";
const DB_USER = "root";
const DB_PASSWORD = "123123";
const DB_NAME = "database";

function loadUsersData(string $userIds): array {
    $result = [];

    $inValues = explode(',', $userIds);

    $preparedInValues = [];
    foreach ($inValues as $index => $value) { // Формирование массива, в котором ключ - :var_<NUMBER>, а значение - каждый из переданных функции id
        $preparedInValues[':key'.$index] = $value;
    }
    
    $pdoObj = new PDO(sprintf("mysql:host=%s;dbname=%s", DB_HOST, DB_NAME), DB_USER, DB_PASSWORD);
    $state = $pdoObj->prepare('SELECT id, name from users WHERE id in (' . implode(',', array_keys($preparedInValues)) . ');');

    if (!$state->execute($preparedInValues)) {
        return [];
    }

    while ($userData = $state->fetch()) {
        $result[$userData['id']] = $userData['name'];
    }

    return $result;
}
// Как правило, в $_GET['userIds'] должна приходить строка
// с номерами пользователей через запятую, например: 1,2,17,48
$userNames = loadUsersData($_GET['userIds']);

foreach ($userNames as $userId => $name) {
    echo "<a href=\"/show_user.php?id=$userId\">$name</a>";
}
```


## Описание решения
Прошлая функция запрашивала пользователей, по одному перебирая айдишники, и при этом создавая новые подключения для каждого из них. В ней была не предусмотрена защита от SQL вставок, ситуация, когда в GET параметре нет айдишников (переменная `$data` бы не создавалась, и выдавалась бы ошибка).
В новом решении всё это предусмотрено. Далее будет описано подробнее

### Оформление
1. Переименовали функцию `load_users_data`, чтобы она соответствовала правилам PSR. Функции должны называться в camelCase;
2. По той же причине что функции, переименовали переменные в camelCase;
3. Добавлены отступы перед возвратом в функции, и закрытием соединения с mysql, чтобы визуально выделить их от остального кода;
4. Добавлены пробелы после ключевого слова while и перед открывающейся фигурной скобкой;
5. Переименованы переменные `$data`. Внутри функции она станет `$result`, а в месте вызова функции она станет `$userNames`;
6. Добавлены пробелы в создании переменных в скобочках в foreach;

### Логика
1. Добавлена строгая типизация для входных параметров в функции, а также тип для возвращаемых данных;
2. Изменён способ обращения к базе данных. Если раньше он был через функцию mysqli, то теперь оно реализовано с помощью библиотеки PDO. Теперь запросы защищены от SQL вставок;
3. Вынесли данные для подключения к бд в константы. По-хорошему, они вообще должны быть в одном месте, а не писаться в какой-то функции;

Для пользователя этой функции, она никак не изменилась. Ей всё так же передают строку, она всё так же возвращает массив с результатом. На деле она больше не создаёт кучу соединений с базой, для каждого из запрашиваемых id, а ей алгоритмическая сложность снизилась.

### Что ещё можно улучшить
Подключение к базе данных не должно находиться в такой функции. Правильнее будет переместить его в отдельный класс, который бы занимался взаимодействиями с базой.
Из-за того, что формирование запросов происходит в этой функции вместе с другими действиями, она кажется большой, и делающей много действий. На самом же деле она только формирует запрос из предоставленных данных, и выдаёт ответ из найденных данных в виде массива.


## Если на проекте используется другая версия PHP

Стоит убрать тип данных для аргумента функции, и возвращаемый тип. Кроме этого, всё остальное должно работать